package designpattern

// 装饰器模式
//在程序设计中，我们常常需要为对象添加新的行为，很多同学的第一个想法就是扩展本体对象，通过继承的方式达到目的。
//但是使用继承不可避免地有如下两个弊端：
//（1）继承时静态的，在编译期间就已经确定，无法在运行时改变对象的行为。
//（2）子类只能有一个父类，当需要添加的新功能太多时，容易导致类的数量剧增。

//对于这种场景，我们通常会使用装饰模式（Decorator Pattern）来解决，
//它使用组合而非继承的方式，能够动态地为本体对象叠加新的行为。 理论上，只要没有限制，它可以一直把功能叠加下去。

//装饰模式最经典的应用当属Java的I/O流体系，通过装饰模式，使用者可以 **动态地为原始的输入输出流添加功能** ，
//比如按照字符串输入输出，添加缓存等，使得整个I/O流体系具有很高的可扩展性和灵活性。
//从结构上看，装饰模式和代理模式具有很高的相似性，但是两种所强调的点不一样。
//前者强调的是为本体对象添加新的功能，后者强调的是对本体对象的访问控制。
//当然，代理模式中的智能引用在笔者看来就跟装饰模式完全一样了。
